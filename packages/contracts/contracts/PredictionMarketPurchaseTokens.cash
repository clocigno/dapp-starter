pragma cashscript ^0.10.0;

contract PredictionMarketPurchaseTokens() {
  //////////////////////////////////////////////////////////////////////////////////////////
 ///////////////////////    Purchase Prediction Market Yes and No Tokens   /////////////////
//////////////////////////////////////////////////////////////////////////////////////////
// Allows liquidity providers to purchase one Yes token and one No Token for 0.001 BCH
// Each token with the correct prediction will be redeemable for 0.001 BCH with an oracle message confirming its correct prediction
// ------------------------------------------------------------------------------------
//inputs: 
//  0   masterNFT                [NFT]       (from this contract - proves contract authorization)
//  1   marketNFT                [NFT]       (from PredictionMarket contract)
//  2   marketYesFungibleTokens  [FT]        (from PredictionMarket contract)
//  3   marketNoFungibleTokens   [FT]        (from PredictionMarket contract)
//  4   LPBCH                    [BCH]       (from LP)
//outputs:                                                      
//  0   masterNFT                [NFT]       (to this contract)  
//  1   marketNFT                [NFT]       (to PredictionMarket contract)     
//  2   BCH for tokens           [BCH]       (to PredictionMarket contract) 
//  3   Yes token change         [FT]        (to PredictionMarket contract) 
//  4   No token change          [FT]        (to PredictionMarket contract) 
//  5   marketYesFungibleTokens  [FT]        (to LP)
//  6   marketNoFungibleTokens   [FT]        (to LP) 
//  7   {optional} change        [BCH]       (to LP)
// ------------------------------------------------------------------------------------
//parameters:
//  event: string representing the prediction to be resolved or an IPFS address with relevant market JSON data i.e. "The Cleveland Browns will win the 2026 Super Bowel"
//////////////////////////////////////////////////////////////////////////////////////////
    function purchaseTokens(string event) {
        require(tx.inputs.length == 5);                                                             // exactly five inputs
        
        require(this.activeInputIndex == 0);                                                        // this contract's UTXO must be input 0         
        require(tx.inputs[0].tokenCategory == masterNFTTokenCategory);                              // verify contract UTXO is a PredictionMarket Master NFT (masterNFTTokenCategory is just a placeholder - the actual contract would have a hardcoded tokenCategory)
        require(tx.inputs[0].nftCommitment == bytes128(0));                                         // verify contract UTXO is the Master NFT (all 0s in the commitment)

        require(tx.inputs[1].lockingBytecode == new LockingBytecodeP2SH32(PredictionMarketHash));   // must come from PredictionMarket contract (PredictionMarketHash is just a placeholder - the actual contract would have a hardcoded hash)
        require(tx.inputs[1].tokenCategory == masterTokenCategory);                                 // input 1 must be an immutable active marketNFT (masterTokenCategory is just a placeholder - the actual contract would have a hardcoded tokenCategory)
        bytes20 marketID = hash160(event);                                                          // hash the string from the function parameter
        bytes20 nftMarketID, bytes108 final108 = tx.inputs[1].nftCommitment.split(20);              // grab the marketID from the nftCommitment
        bytes20 yesTokenCategoryHash, bytes88 final88 = final108.split(20);                         // grab the hash of the Yes tokenCategory from the nftCommitment
        bytes20 noTokenCategoryHash = final88.split(20)[0];                                         // grab the hash of the No tokenCategory from the nftCommitment
        require(marketID == nftMarketID);                                                           // the marketID derived from the function parameter must match the one on the nftCommitment
        require(yesTokenCategoryHash == hash160(tx.inputs[2].tokenCategory));                       // the hash of the Yes tokenCategory from the nftCommitment must match the hash of input 2's tokenCategory
        require(noTokenCategoryHash == hash160(tx.inputs[3].tokenCategory));                        // the hash of the No tokenCategory from the nftCommitment must match the hash of input 3's tokenCategory

        int inputIndex = 2;                                                                                     // index for loop
        do {
            require(tx.inputs[inputIndex].lockingBytecode == new LockingBytecodeP2SH32(PredictionMarketHash));  // must come from PredictionMarket contract (PredictionMarketHash is just a placeholder - the actual contract would have a hardcoded hash)
            inputIndex = inputIndex + 1;                                                                        // increment index
        } while(inputIndex < 4);                                                                                // loop goes through inputs 2 and 3

        require(tx.inputs[4].lockingBytecode == new LockingBytecodeP2SH32(PredictionMarketHash));   // must come from PredictionMarket contract (PredictionMarketHash is just a placeholder - the actual contract would have a hardcoded hash)

        require(tx.inputs[4].tokenCategory == 0x);                                                  // input 4 must have no tokens
//
//

        require(tx.outputs.length <= 8);                                                            // eight or less outputs

        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);                     // recreate masterNFT on this contract
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);                         // carry forward category + capability
        require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);                             // carry forward token balance
        require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment);                         // carry forward commitment
        require(tx.outputs[0].value == tx.inputs[0].value);                                         // carry forward satoshis

        require(tx.outputs[1].lockingBytecode == tx.inputs[1].lockingBytecode);                     // recreate marketNFT on PredictionMarket contract
        require(tx.outputs[1].tokenCategory == tx.inputs[1].tokenCategory);                         // carry forward category + capability
        require(tx.outputs[1].tokenAmount == tx.inputs[1].tokenAmount);                             // carry forward token balance
        require(tx.outputs[1].nftCommitment == tx.inputs[1].nftCommitment);                         // carry forward nftCommitment                
        require(tx.outputs[1].value == tx.inputs[1].value);                                         // carry forward satoshis                 

        require(tx.outputs[3].lockingBytecode == tx.inputs[1].lockingBytecode);                      // send BCH to Prediction Market contract

        require(tx.outputs[4].lockingBytecode == tx.inputs[1].lockingBytecode);                      // send Yes fungible tokens change to PredictionMarket contract
        require(tx.outputs[4].tokenAmount == tx.inputs[3].tokenAmount - tx.outputs[6].tokenAmount);  // tokenAmount is the orginal amount in the input UTXO - what the LP will receive
        require(tx.outputs[4].value == tx.inputs[3].value);                                          // carry forward satoshis  

        require(tx.outputs[5].lockingBytecode == tx.inputs[1].lockingBytecode);                      // send No fungible tokens change to PredictionMarket contract
        require(tx.outputs[5].tokenAmount == tx.inputs[4].tokenAmount - tx.outputs[7].tokenAmount);  // tokenAmount is the orginal amount in the input UTXO - what the LP will receive
        require(tx.outputs[5].value == tx.inputs[4].value);                                          // carry forward satoshis  

        require(tx.outputs[6].lockingBytecode == tx.inputs[5].lockingBytecode);                      // Yes tokens to LP
        require(tx.outputs[6].tokenCategory == tx.inputs[3].tokenCategory);                          // check category
        require(tx.outputs[6].tokenAmount == tx.inputs[5].value / 100_000);                          // LP will receive one Yes FT per 0.001 BCH spent
        require(tx.outputs[6].value == 1000);                                                        // set UTXO satoshis to 1000 (for existence)

        require(tx.outputs[7].lockingBytecode == tx.inputs[5].lockingBytecode);                      // No tokens to LP
        require(tx.outputs[7].tokenCategory == tx.inputs[4].tokenCategory);                          // check category
        require(tx.outputs[7].tokenAmount == tx.inputs[5].value / 100_000);                          // LP will receive one No FT per 0.001 BCH spent
        require(tx.outputs[7].value == 1000);                                                        // set UTXO satoshis to 1000 (for existence)

        if (tx.outputs.length == 9) {                                                               // {optional} change output
            require(tx.outputs[8].lockingBytecode == tx.inputs[5].lockingBytecode);                 // change must be sent to LP's address
            require(tx.outputs[8].tokenCategory == 0x);                                             // change must not have tokens
        }
    }
}