pragma cashscript ^0.13.0;

contract PredictionMarketProvideLiquidity() {
  //////////////////////////////////////////////////////////////////////////////////////////
 ///////////////////////    Provide Liquity to a Prediction Market   //////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
// ------------------------------------------------------------------------------------
//inputs: 
//  0   masterNFT                [NFT]       (from this contract - proves contract authorization)
//  1   receiptNFT - Minting     [NFT]       (from this contract - provides LP with NFT receipt for withdrawing liquidity and fees later)
//  2   marketNFT                [NFT]       (from PredictionMarketManager contract)
//  3   yesTokens                [FT]        (from PredictionMarketManager contract - LP is required to buy an amount of yes/no shares to keep market in balance)
//  4   noTokens                 [FT]        (from PredictionMarketManager contract - LP is required to buy an amount of yes/no shares to keep market in balance)
//  5   LP BCH                   [BCH]       (from LP)
//outputs:                                                     
//  0   masterNFT                [NFT]       (to this contract)  
//  1   receiptNFT - Minting     [NFT]       (to this contract)  
//  2   marketNFT                [NFT]       (to PredictionMarketManager contract)     
//  3   BCH for LP claim         [BCH]       (to PredictionMarketManager contract) 
//  4   yesTokenChange           [FT]        (to PredictionMarketManager contract) 
//  5   noTokenChange            [FT]        (to PredictionMarketManager contract) 
//  6   receiptNFT               [NFT]       (to LP)
//  7   {optional} yesTokens     [FT]        (to LP)
//  8   {optional} noTokens      [FT]        (to LP)
//  9   change                   [BCH]       (to LP)
// ------------------------------------------------------------------------------------
//marketNFT committment:
//  marketID                  [20 bytes] (hash of a event string or IPFS address that becomes marketID)
//  yes tokenCategory hash    [20 bytes] (hash of one of the tokenCategory of one of the fungible tokens, redeemable for 0.001 BCH with an oracle message confirming its correct prediction)
//  no tokenCategory hash     [20 bytes] (hash of one of the tokenCategory of one of the fungible tokens, redeemable for 0.001 BCH with an oracle message confirming its correct prediction)
//  creatorPKH                [20 bytes] (pubkey hash of the market creator (likely frontend platform) who provides the BCH UTXOs)  
//  oraclePKH                 [20 bytes] (pubkey hash for the oracle that will decide the market's outcome, Yes or No)
//  creator basis points fee  [1 bytes]  (trading fee that goes to market creator, in percentage basis points)
//  oracle basis points fee   [1 bytes]  (trading fee that goes to oracle, in percentage basis points)
//  LP basis points fee       [1 bytes]  (trading fee that goes to liquiity provider)
//  b                         [6 bytes]  (measure of liquidity pool depth, starts at 0 and goes up as liquity is added)
//  q_yes                     [6 bytes]  (quantity of "Yes" unit shares outstanding in sats, starts at 0 amd goes up as "Yes" shares are purchased)
//  q_no                      [6 bytes]  (quantity of "No" unit shares outstanding in sats, starts at 0 amd goes up as "No" shares are purchased)
//  trading fees              [6 bytes]  (accumulated trading fees)
//  market status             [1 byte]   (from oracle messages)
// ___________________________________
//  total                     [128 bytes]
// ------------------------------------------------------------------------------------
// receiptNFT committment:
//  marketID                  [20 bytes] (hash of a event string or IPFS address that becomes marketID)
//  delta b                   [6 bytes]  (amount of liquidity provided to the market)
// ___________________________________
//  total                     [26 bytes]
// ------------------------------------------------------------------------------------
//parameters:
//  event: string representing the prediction to be resolved or an IPFS address with relevant market JSON data i.e. "The Cleveland Browns will win the 2026 Super Bowel"
//  delta_b: int representing how much liquidity to be added (adding 100 b to a pool of 900 b, would mean you could claim 10% of the trading fees reserved for LPs)
//////////////////////////////////////////////////////////////////////////////////////////
    int SCALE = 1 << 60;  // Fixed-point scale factor (2^60)
    int LN2_FIXED = 799144290325165952;  // ln(2) * SCALE
    int INV_LN2_FIXED = 1663314137230540288;  // 1 / ln(2) * SCALE
    int PAYOUT_PER_SHARE = 100000;  // sats payout per fungible token

    function bitLength(int x) : int {  // Computes bit length of x 
        if (x <= 0) {
            return 0;  // Handle non-positive
        }
        int length = 0;
        int temp = x;
        // Loop with right shifts to count bits
        do {
            length = length + 1;  // Increment bit count
            temp = temp >> 1;  // Shift right (divide by 2)
            if (temp == 0) {
                break;  // Stop if no bits left
            }
        } while (true);
        return length;
    }

    function floor_div(int a, int b) : int {  // Emulates Python floor division (rounds towards -inf)
        int quot = a / b;  // Integer quotient (truncates towards zero)
        int rem = a % b;  // Remainder
        // If signs differ and remainder exists, adjust down
        if ((a < 0 && b > 0) || (a > 0 && b < 0)) {
            if (rem != 0) {
                quot = quot - 1;  // Floor adjustment for negative cases
            }
        }
        return quot;
    }

    function approx_exp_fixed(int x_fixed) : int {  // Approximates exp(x_fixed / SCALE) * SCALE using Taylor series
        int result = SCALE;  // Start with 1.0 in fixed-point
        int term = x_fixed;  // First term: x
        result = result + term;
        int k = 2;
        do {
            term = floor_div(term * x_fixed, SCALE * k);  // Next term: prev * x / (k * SCALE)
            result = result + term;  // Accumulate
            if (abs(term) < 1) {
                break;  // Stop if term negligible
            }
            k = k + 1;
            if (k >= 100) {
                break;  // Safety cap
            }
        } while (true);
        return result;
    }

    function approx_pow2_fixed(int x_fixed) : int {  // Approximates 2^(x_fixed / SCALE) * SCALE
        int exponent_fixed = floor_div(x_fixed * LN2_FIXED, SCALE);  // x * ln(2) for exp conversion
        if (exponent_fixed < -60 * SCALE) {
            return 0;  // Underflow to zero
        } else {
            return approx_exp_fixed(exponent_fixed);  // Compute via exp
        }
    }

    function approx_ln1p_fixed(int u_fixed) : int {  // Approximates ln(1 + u_fixed / SCALE) * SCALE using Taylor series
        if (u_fixed == 0) {
            return 0;  // Base case
        }
        int result = 0;
        int power = u_fixed;  // Start with u
        int sign = 1;
        int term = power / 1;  // First term: u/1
        result = result + sign * term;
        int k = 2;
        do {
            power = floor_div(power * u_fixed, SCALE);  // Next power: prev * u / SCALE
            if (power == 0) {
                break;  // Underflow stop
            }
            term = power / k;  // Term: power / k (integer div)
            sign = -sign;  // Alternate sign
            result = result + sign * term;
            if (abs(term) < 1) {
                break;  // Negligible term stop
            }
            k = k + 1;
            if (k >= 100000) {
                break;  // Safety cap
            }
        } while (true);
        return result;
    }

    function approx_log2_fixed(int y_fixed) : int {  // Approximates log2(y_fixed / SCALE) * SCALE
        if (y_fixed <= 0) {
            require(false, "y must be positive");  // Error on invalid input
        }
        if (y_fixed < 1) {
            return 0;  // Tiny values to zero
        }
        int exp = bitLength(y_fixed) - 1;  // Integer part of log2
        int shift = 60 - exp;  // Shift to normalize to [1,2) * SCALE
        int mantissa_fixed;
        if (shift > 0) {
            mantissa_fixed = y_fixed << shift;  // Multiply by 2^shift
        } else {
            mantissa_fixed = y_fixed >> (-shift);  // Divide by 2^|shift|
        }
        int u_fixed = mantissa_fixed - SCALE;  // u for ln(1+u)
        int ln_frac = approx_ln1p_fixed(u_fixed);  // Fractional ln
        int frac_log2_fixed = floor_div(ln_frac * INV_LN2_FIXED, SCALE);  // Convert to log2
        int total_log2_fixed = (exp - 60) * SCALE + frac_log2_fixed;  // Combine integer + fraction
        return total_log2_fixed;
    }

    function lmsr_cost(int b, int q_yes, int q_no) : int {  // Computes LMSR cost C = b * log2(2^{q_yes/b} + 2^{q_no/b})
        int x_yes_fixed = floor_div(q_yes * SCALE, b);  // q_yes / b * SCALE
        int pow_yes = approx_pow2_fixed(x_yes_fixed);  // 2^{q_yes/b} * SCALE
        int x_no_fixed = floor_div(q_no * SCALE, b);  // q_no / b * SCALE
        int pow_no = approx_pow2_fixed(x_no_fixed);  // 2^{q_no/b} * SCALE
        int sum_fixed = pow_yes + pow_no;  // Sum * SCALE
        int log2_fixed = approx_log2_fixed(sum_fixed);  // log2(sum) * SCALE
        int cost = floor_div(b * log2_fixed, SCALE);  // b * log2(sum)
        return cost;
    }

    function provideLiquidity(string event, int delta_b) {
        require(delta_b > 0);                                                                       // must be adding liquidity

        require(tx.inputs.length == 6);                                                             // exactly six inputs
        
        require(tx.inputs[0].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);  // UTXO must ome from this contract       
        require(tx.inputs[0].tokenCategory == masterNFTTokenCategory);                              // verify UTXO is a PredictionMarket Master NFT (masterNFTTokenCategory is just a placeholder - the actual contract would have a hardcoded tokenCategory)
        require(tx.inputs[0].nftCommitment == bytes128(0));                                         // all 0s in the commitment

        require(tx.inputs[1].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);  // UTXO must come from this contract      
        require(tx.inputs[1].tokenCategory == receiptNFTTokenCategory + 0x02);                      // verify contract UTXO is a minting PredictionMarket Receipt NFT (receiptNFTTokenCategory is just a placeholder - the actual contract would have a hardcoded tokenCategory)
        require(tx.inputs[1].nftCommitment == bytes26(0));                                          // all 0s in the commitment

        bytes20 marketID = hash160(event);                                                                 // hash the string from the function parameter
        bytes20 nftMarketID, bytes108 final108 = tx.inputs[2].nftCommitment.split(20);                     // grab the marketID from the nftCommitment

        require(tx.inputs[2].lockingBytecode == new LockingBytecodeP2SH32(PredictionMarketManagerHash));   // must come from PredictionMarketManager contract (PredictionMarketManagerHash is just a placeholder - the actual contract would have a hardcoded hash)
        require(tx.inputs[2].tokenCategory == masterTokenCategory);                                        // must be an immutable active marketNFT (masterTokenCategory is just a placeholder - the actual contract would have a hardcoded tokenCategory)
        require(marketID == nftMarketID);                                                                  // the marketID derived from the function parameter must match the one on the nftCommitment

        bytes20 yesTokenCategory, bytes88 final88 = final108.split(20);                                    // grab yes token category from marketNFT
        bytes20 noTokencategory, bytes68 final68 = final88.split(20);                                      // grab no token category from marketNFT

        require(tx.inputs[3].lockingBytecode == new LockingBytecodeP2SH32(PredictionMarketManagerHash));   // must come from PredictionMarketManager contract (PredictionMarketManagerHash is just a placeholder - the actual contract would have a hardcoded hash)
        require(tx.inputs[3].tokenCategory == yesTokenCategory);                                           // must match the yes token category from the marketNFT commitment

        require(tx.inputs[4].lockingBytecode == new LockingBytecodeP2SH32(PredictionMarketManagerHash));   // must come from PredictionMarketManager contract (PredictionMarketManagerHash is just a placeholder - the actual contract would have a hardcoded hash)
        require(tx.inputs[4].tokenCategory == noTokencategory);                                            // must match the no token category from the marketNFT commitment

        require(tx.inputs[5].tokenCategory == 0x);                                                  // must have no tokens

        require(tx.outputs.length <= 10);                                                           // ten or less outputs

        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);                     // recreate masterNFT on this contract
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);                         // carry forward category + capability
        require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);                             // carry forward token balance
        require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment);                         // carry forward commitment
        require(tx.outputs[0].value == tx.inputs[0].value);                                         // carry forward satoshis

        require(tx.outputs[1].lockingBytecode == tx.inputs[1].lockingBytecode);                     // recreate minting receiptNFT on this contract
        require(tx.outputs[1].tokenCategory == tx.inputs[1].tokenCategory);                         // carry forward category + capability
        require(tx.outputs[1].tokenAmount == tx.inputs[1].tokenAmount);                             // carry forward token balance
        require(tx.outputs[1].nftCommitment == tx.inputs[1].nftCommitment);                         // carry forward nftCommitment                
        require(tx.outputs[1].value == tx.inputs[1].value);                                         // carry forward satoshis        

        bytes43 next43, bytes25 last25 = final68.split(43);
        bytes6 b_current, bytes19 last19 = last25.split(6);                                         // grab current b from marketNFT commitment
        bytes6 q_yes_curent, bytes13 last13 = last19.split(6);                                      // grab current q_yes from marketNFT commitment
        bytes6 q_no_current, bytes7 last7 = last13.split(6);                                        // grab current q_no from marketNFT commitment
        bytes6 trading_fees_current, byte marketStatus = last7.split(6);                            // grab market status
        require(marketStatus == 3);                                                                 // market must still be active
        int b_new = int(b_current) + delta_b;                                                       // calculate new b value after this transaction
        int k_fixed = floor_div(b_new * SCALE, b_current);                                          // scaling ratio * SCALE (fixed-point)
        int q_yes_new = floor_div(int(q_yes_current) * k_fixed, SCALE);                             // scaled q_yes (proportional to b increase)
        int q_no_new = floor_div(int(q_no_current) * k_fixed, SCALE);                               // scaled q_no (proportional to b increase)

        require(tx.outputs[2].lockingBytecode == tx.inputs[2].lockingBytecode);                     // recreate marketNFT on PredictionMarketManager contract
        require(tx.outputs[2].tokenCategory == tx.inputs[2].tokenCategory);                         // carry forward category + capability
        require(tx.outputs[2].tokenAmount == tx.inputs[2].tokenAmount);                             // carry forward token balance
        require(tx.outputs[2].nftCommitment == tx.inputs[2].nftCommitment == nftMarketID +          // carry over the first part of the commitment as is
                                                                             yesTokenCategory +
                                                                             noTokencategory +
                                                                             next43 +
                                                                             bytes6(b_new) +        // update b 
                                                                             bytes6(q_yes_new) +    // update q_yes
                                                                             bytes6(q_no_new) +     // update q_no
                                                                             last7
                );
        require(tx.outputs[2].value == tx.inputs[2].value);                                         // carry forward satoshis                 

        int c_current = lmsr_cost(int(b_current), int(q_yes_current), int(q_no_current));           // calc LMSR cost before tx
        int c_new = lmsr_cost(b_new, q_yes_new, q_no_new);                                          // calc LMSR cost after tx
        int deposit = c_new - c_current;                                                            // difference is what user owes
        require(deposit > 0);                                                                       // depsoit amount must be > 0

        require(tx.outputs[3].lockingBytecode == tx.inputs[2].lockingBytecode);                     // send BCH to PredictionMarketManager contract
        require(tx.outputs[3].tokenCategory == 0x);                                                 // no tokens on output 3
        require(tx.outputs[3].value >= deposit);                                                    // must be at least the deposit required
        
        int delta_yes = q_yes_new - int(q_yes_current);                                             // calc change in q_yes
        int delta_no = q_no_new - int(q_no_current);                                                // calc change in q_no
        int lp_yes_tokens = floor_div(delta_yes, PAYOUT_PER_SHARE);                                 // calc yes tokens owed to LP
        int lp_no_tokens = floor_div(delta_no, PAYOUT_PER_SHARE);                                   // calc no tokens owed to LP

        require(tx.outputs[4].lockingBytecode == tx.inputs[2].lockingBytecode);                     // send yes token change to PredictionMarketManager contract
        require(tx.outputs[4].tokenCategory == tx.inputs[3].tokenCategory);                         // tokenCategory should match the yes token category from earlier
        require(tx.outputs[4].tokenAmount == tx.inputs[3].tokenAmount - lp_yes_tokens);             // token amount should be the original token amount - what was sent to LP
        require(tx.outputs[4].value == tx.inputs[3].value);                                         // carry over sats

        require(tx.outputs[5].lockingBytecode == tx.inputs[2].lockingBytecode);                     // send no token change to PredictionMarketManager contract
        require(tx.outputs[5].tokenCategory == tx.inputs[4].tokenCategory);                         // tokenCategory should match the yes token category from earlier
        require(tx.outputs[5].tokenAmount == tx.inputs[4].tokenAmount - lp_no_tokens);              // token amount should be the original token amount - what was sent to LP
        require(tx.outputs[5].value == tx.inputs[4].value);                                         // carry over sats

        require(tx.outputs[6].lockingBytecode == tx.inputs[5].lockingBytecode);                     // receipt NFT should be sent to LP
        require(tx.outputs[6].tokenCategory == tx.inputs[1].tokenCategory.split(32)[0]);            // same token category as the minting receipt NFT but immutable
        require(tx.outputs[6].tokenAmount == 0);                                                    // no fungible tokens here
        require(tx.outputs[6].nftCommitment == marketID + bytes6(delta_b));                         // set NFT commitment on receipt = marketID + liquidity provided in this tx
        require(tx.outputs[6].value == 1000);                                                       // set UTXO satoshis to 1000 (for existence)                

        int outputIndex = 7;                                                                        // index for uncertain outputs  

        // Neutral Yes tokens to LP (only if >0)
        if (lp_yes_tokens > 0) {
            require(tx.outputs[outputIndex].lockingBytecode == tx.inputs[5].lockingBytecode);       // yes tokens should be sent to LP
            require(tx.outputs[outputIndex].tokenCategory == tx.inputs[3].tokenCategory);           // tokenCategory should match the yes token category from earlier
            require(tx.outputs[outputIndex].tokenAmount == lp_yes_tokens);                          // token amount should match the calulation above
            require(tx.outputs[outputIndex].value == 1000);                                         // set UTXO satoshis to 1000 (for existence)
            outputIndex = outputIndex + 1;
        }

        // Neutral No tokens to LP (only if >0)
        if (lp_no_tokens > 0) {
            require(tx.outputs[outputIndex].lockingBytecode == tx.inputs[5].lockingBytecode);       // no tokens should be sent to LP
            require(tx.outputs[outputIndex].tokenCategory == tx.inputs[4].tokenCategory);           // tokenCategory should match the no token category from earlier
            require(tx.outputs[outputIndex].tokenAmount == lp_no_tokens);                           // token amount should match the calulation above
            require(tx.outputs[outputIndex].value == 1000);                                         // set UTXO satoshis to 1000 (for existence)
            outputIndex = outputIndex + 1;
        }

        require(tx.outputs[outputIndex].lockingBytecode == tx.inputs[5].lockingBytecode);           // change must be sent to LP's address
        require(tx.outputs[outputIndex].tokenCategory == 0x);                                       // change must not have tokens
    }
}