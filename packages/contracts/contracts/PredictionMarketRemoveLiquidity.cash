pragma cashscript ^0.13.0;

contract PredictionMarketRemoveLiquidity() {
  //////////////////////////////////////////////////////////////////////////////////////////
 ///////////////////////    Remove Liquity to from a Prediction Market   //////////////////
//////////////////////////////////////////////////////////////////////////////////////////
// ------------------------------------------------------------------------------------
//inputs: 
//  0   masterNFT                [NFT]       (from this contract - proves contract authorization)
//  1   receiptNFT - Minting     [NFT]       (from this contract - for partial liquidity removals where LP will still have liquidity in the pool)
//  2   marketNFT                [NFT]       (from PredictionMarketManager contract)
//  3   LP BCH                   [BCH]       (from PredictionMarketManager contract)
//  4   receiptNFT               [NFT]       (from LP)
//outputs:                                                     
//  0   masterNFT                [NFT]       (to this contract)  
//  1   receiptNFT - Minting     [NFT]       (to this contract)  
//  2   marketNFT                [NFT]       (to PredictionMarketManager contract)     
//  3   change                   [BCH]       (to PredictionMarketManager contract)
//  4   BCH for LP claim         [BCH]       (to LP) 
//  5   {optional} new receipt   [NFT]       (to LP) 
// ------------------------------------------------------------------------------------
//marketNFT committment:
//  marketID                  [20 bytes] (hash of a event string or IPFS address that becomes marketID)
//  yes tokenCategory hash    [20 bytes] (hash of one of the tokenCategory of one of the fungible tokens, redeemable for 0.001 BCH with an oracle message confirming its correct prediction)
//  no tokenCategory hash     [20 bytes] (hash of one of the tokenCategory of one of the fungible tokens, redeemable for 0.001 BCH with an oracle message confirming its correct prediction)
//  creatorPKH                [20 bytes] (pubkey hash of the market creator (likely frontend platform) who provides the BCH UTXOs)  
//  oraclePKH                 [20 bytes] (pubkey hash for the oracle that will decide the market's outcome, Yes or No)
//  creator basis points fee  [1 bytes]  (trading fee that goes to market creator, in percentage basis points)
//  oracle basis points fee   [1 bytes]  (trading fee that goes to oracle, in percentage basis points)
//  LP basis points fee       [1 bytes]  (trading fee that goes to liquiity provider)
//  b                         [6 bytes]  (measure of liquidity pool depth, starts at 0 and goes up as liquity is added)
//  q_yes                     [6 bytes]  (quantity of "Yes" unit shares outstanding in sats, starts at 0 amd goes up as "Yes" shares are purchased)
//  q_no                      [6 bytes]  (quantity of "No" unit shares outstanding in sats, starts at 0 amd goes up as "No" shares are purchased)
//  trading fees              [6 bytes]  (accumulated trading fees)
//  market status             [1 byte]   (from oracle messages)
// ___________________________________
//  total                     [128 bytes]
// ------------------------------------------------------------------------------------
// receiptNFT committment:
//  marketID                  [20 bytes] (hash of a event string or IPFS address that becomes marketID)
//  delta b                   [6 bytes]  (amount of liquidity provided to the market)
// ___________________________________
//  total                     [26 bytes]
// ------------------------------------------------------------------------------------
//parameters:
//  event: string representing the prediction to be resolved or an IPFS address with relevant market JSON data i.e. "The Cleveland Browns will win the 2026 Super Bowel"
//  delta_b: int representing how much liquidity to be removed 
//////////////////////////////////////////////////////////////////////////////////////////
    int SCALE = 1 << 60;  // Fixed-point scale factor (2^60)
    int LN2_FIXED = 799144290325165952;  // ln(2) * SCALE
    int INV_LN2_FIXED = 1663314137230540288;  // 1 / ln(2) * SCALE
    int PAYOUT_PER_SHARE = 100000;  // sats payout per fungible token

    function bitLength(int x) : int {  // Computes bit length of x 
        if (x <= 0) {
            return 0;  // Handle non-positive
        }
        int length = 0;
        int temp = x;
        // Loop with right shifts to count bits
        do {
            length = length + 1;  // Increment bit count
            temp = temp >> 1;  // Shift right (divide by 2)
            if (temp == 0) {
                break;  // Stop if no bits left
            }
        } while (true);
        return length;
    }

    function floor_div(int a, int b) : int {  // Emulates Python floor division (rounds towards -inf)
        int quot = a / b;  // Integer quotient (truncates towards zero)
        int rem = a % b;  // Remainder
        // If signs differ and remainder exists, adjust down
        if ((a < 0 && b > 0) || (a > 0 && b < 0)) {
            if (rem != 0) {
                quot = quot - 1;  // Floor adjustment for negative cases
            }
        }
        return quot;
    }

    function approx_exp_fixed(int x_fixed) : int {  // Approximates exp(x_fixed / SCALE) * SCALE using Taylor series
        int result = SCALE;  // Start with 1.0 in fixed-point
        int term = x_fixed;  // First term: x
        result = result + term;
        int k = 2;
        do {
            term = floor_div(term * x_fixed, SCALE * k);  // Next term: prev * x / (k * SCALE)
            result = result + term;  // Accumulate
            if (abs(term) < 1) {
                break;  // Stop if term negligible
            }
            k = k + 1;
            if (k >= 100) {
                break;  // Safety cap
            }
        } while (true);
        return result;
    }

    function approx_pow2_fixed(int x_fixed) : int {  // Approximates 2^(x_fixed / SCALE) * SCALE
        int exponent_fixed = floor_div(x_fixed * LN2_FIXED, SCALE);  // x * ln(2) for exp conversion
        if (exponent_fixed < -60 * SCALE) {
            return 0;  // Underflow to zero
        } else {
            return approx_exp_fixed(exponent_fixed);  // Compute via exp
        }
    }

    function approx_ln1p_fixed(int u_fixed) : int {  // Approximates ln(1 + u_fixed / SCALE) * SCALE using Taylor series
        if (u_fixed == 0) {
            return 0;  // Base case
        }
        int result = 0;
        int power = u_fixed;  // Start with u
        int sign = 1;
        int term = power / 1;  // First term: u/1
        result = result + sign * term;
        int k = 2;
        do {
            power = floor_div(power * u_fixed, SCALE);  // Next power: prev * u / SCALE
            if (power == 0) {
                break;  // Underflow stop
            }
            term = power / k;  // Term: power / k (integer div)
            sign = -sign;  // Alternate sign
            result = result + sign * term;
            if (abs(term) < 1) {
                break;  // Negligible term stop
            }
            k = k + 1;
            if (k >= 100000) {
                break;  // Safety cap
            }
        } while (true);
        return result;
    }

    function approx_log2_fixed(int y_fixed) : int {  // Approximates log2(y_fixed / SCALE) * SCALE
        if (y_fixed <= 0) {
            require(false, "y must be positive");  // Error on invalid input
        }
        if (y_fixed < 1) {
            return 0;  // Tiny values to zero
        }
        int exp = bitLength(y_fixed) - 1;  // Integer part of log2
        int shift = 60 - exp;  // Shift to normalize to [1,2) * SCALE
        int mantissa_fixed;
        if (shift > 0) {
            mantissa_fixed = y_fixed << shift;  // Multiply by 2^shift
        } else {
            mantissa_fixed = y_fixed >> (-shift);  // Divide by 2^|shift|
        }
        int u_fixed = mantissa_fixed - SCALE;  // u for ln(1+u)
        int ln_frac = approx_ln1p_fixed(u_fixed);  // Fractional ln
        int frac_log2_fixed = floor_div(ln_frac * INV_LN2_FIXED, SCALE);  // Convert to log2
        int total_log2_fixed = (exp - 60) * SCALE + frac_log2_fixed;  // Combine integer + fraction
        return total_log2_fixed;
    }

    function lmsr_cost(int b, int q_yes, int q_no) : int {  // Computes LMSR cost C = b * log2(2^{q_yes/b} + 2^{q_no/b})
        int x_yes_fixed = floor_div(q_yes * SCALE, b);  // q_yes / b * SCALE
        int pow_yes = approx_pow2_fixed(x_yes_fixed);  // 2^{q_yes/b} * SCALE
        int x_no_fixed = floor_div(q_no * SCALE, b);  // q_no / b * SCALE
        int pow_no = approx_pow2_fixed(x_no_fixed);  // 2^{q_no/b} * SCALE
        int sum_fixed = pow_yes + pow_no;  // Sum * SCALE
        int log2_fixed = approx_log2_fixed(sum_fixed);  // log2(sum) * SCALE
        int cost = floor_div(b * log2_fixed, SCALE);  // b * log2(sum)
        return cost;
    }

    function removeLiquidity(string event, int delta_b) {
        require(delta_b < 0);                                                                       // must be removing liquidity

        require(tx.inputs.length == 5);                                                             // exactly five inputs
        
        require(tx.inputs[0].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);  // UTXO must ome from this contract       
        require(tx.inputs[0].tokenCategory == masterNFTTokenCategory);                              // verify UTXO is a PredictionMarket Master NFT (masterNFTTokenCategory is just a placeholder - the actual contract would have a hardcoded tokenCategory)
        require(tx.inputs[0].nftCommitment == bytes128(0));                                         // all 0s in the commitment

        require(tx.inputs[1].lockingBytecode == tx.inputs[this.activeInputIndex].lockingBytecode);  // UTXO must come from this contract      
        require(tx.inputs[1].tokenCategory == receiptNFTTokenCategory + 0x02);                      // verify contract UTXO is a minting PredictionMarket Receipt NFT (receiptNFTTokenCategory is just a placeholder - the actual contract would have a hardcoded tokenCategory)
        require(tx.inputs[1].nftCommitment == bytes26(0));                                          // all 0s in the commitment

        bytes20 marketID = hash160(event);                                                                 // hash the string from the function parameter
        bytes20 nftMarketID, bytes108 final108 = tx.inputs[2].nftCommitment.split(20);                     // grab the marketID from the nftCommitment

        require(tx.inputs[2].lockingBytecode == new LockingBytecodeP2SH32(PredictionMarketManagerHash));   // must come from PredictionMarketManager contract (PredictionMarketManagerHash is just a placeholder - the actual contract would have a hardcoded hash)
        require(tx.inputs[2].tokenCategory == masterTokenCategory);                                        // must be an immutable active marketNFT (masterTokenCategory is just a placeholder - the actual contract would have a hardcoded tokenCategory)
        require(marketID == nftMarketID);                                                                  // the marketID derived from the function parameter must match the one on the nftCommitment

        require(tx.inputs[3].tokenCategory == 0x);                                                         // must have no tokens
        require(tx.inputs[3].lockingBytecode == new LockingBytecodeP2SH32(PredictionMarketManagerHash));   // must come from PredictionMarketManager contract (PredictionMarketManagerHash is just a placeholder - the actual contract would have a hardcoded hash)

        bytes20 receiptMarketID, bytes6 LP_b_current = tx.inputs[4].nftCommitment.split(20);        // grab info from receipt

        require(receiptMarketID == marketID);                                                       // receipt marketID from match the one from parameters and from market NFT
        require(int(LP_b_current) > 0);                                                                  // must have liquidity in pool
        require(tx.inputs[4].tokenCategory == receiptNFTTokenCategory);                             // must be a PredictionMarket Receipt NFT (receiptNFTTokenCategory is just a placeholder - the actual contract would have a hardcoded tokenCategory)
        require(tx.inputs[4].tokenAmount == 0);                                                     // no fungible tokens here

        require(tx.outputs.length <= 6);                                                            // six or less outputs

        require(tx.outputs[0].lockingBytecode == tx.inputs[0].lockingBytecode);                     // recreate masterNFT on this contract
        require(tx.outputs[0].tokenCategory == tx.inputs[0].tokenCategory);                         // carry forward category + capability
        require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);                             // carry forward token balance
        require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment);                         // carry forward commitment
        require(tx.outputs[0].value == tx.inputs[0].value);                                         // carry forward satoshis

        require(tx.outputs[1].lockingBytecode == tx.inputs[1].lockingBytecode);                     // recreate minting receiptNFT on this contract
        require(tx.outputs[1].tokenCategory == tx.inputs[1].tokenCategory);                         // carry forward category + capability
        require(tx.outputs[1].tokenAmount == tx.inputs[1].tokenAmount);                             // carry forward token balance
        require(tx.outputs[1].nftCommitment == tx.inputs[1].nftCommitment);                         // carry forward nftCommitment                
        require(tx.outputs[1].value == tx.inputs[1].value);                                         // carry forward satoshis        

        bytes100 first103, bytes25 last25 = tx.inputs[2].nftCommitment.split(103);                  // grab last 25 bytes of marketNFT commitment
        bytes6 b_current, bytes19 last19 = last25.split(6);                                         // grab current b from marketNFT commitment
        bytes6 q_yes_curent, bytes13 last13 = last19.split(6);                                      // grab current q_yes from marketNFT commitment
        bytes6 q_no_current, bytes7 last7 = last13.split(6);                                        // grab current q_no from marketNFT commitment
        bytes6 trading_fees_current, byte marketStatus = last7.split(6);                            // grab current accumulated trading fees from marketNFT commitment
        int b_new = int(b_current) + delta_b;                                                       // calculate new b value after this transaction
        int k_fixed = floor_div(b_new * SCALE, b_current);                                          // scaling ratio * SCALE (fixed-point)
        int q_yes_new = floor_div(int(q_yes_current) * k_fixed, SCALE);                             // new scaled q_yes (proportional to b increase)
        int q_no_new = floor_div(int(q_no_current) * k_fixed, SCALE);                               // new scaled q_no (proportional to b increase)
        int fee_share = floor_div(-delta_b * int(trading_fees_current), int(b_current));            // LP's pro-rata fees
        int trading_fees_new = trading_fees_current - fee_share;                                    // new updated accumulated trading fees for commitment

        require(tx.outputs[2].lockingBytecode == tx.inputs[2].lockingBytecode);                     // recreate marketNFT on PredictionMarketManager contract
        require(tx.outputs[2].tokenCategory == tx.inputs[2].tokenCategory);                         // carry forward category + capability
        require(tx.outputs[2].tokenAmount == tx.inputs[2].tokenAmount);                             // carry forward token balance
        require(tx.outputs[2].nftCommitment == tx.inputs[2].nftCommitment == first103 +
                                                                             bytes6(b_new) +            // update b 
                                                                             bytes6(q_yes_new) +        // update q_yes
                                                                             bytes6(q_no_new) +         // update q_no
                                                                             bytes6(trading_fees_new) + // update trading fees
                                                                             marketStatus;
                );
        require(tx.outputs[2].value == tx.inputs[2].value);                                         // carry forward satoshis                 

        int c_current = lmsr_cost(int(b_current), int(q_yes_current), int(q_no_current));           // calc LMSR cost before tx
        int c_new = lmsr_cost(b_new, q_yes_new, q_no_new);                                          // calc LMSR cost after tx
        int withdrawl = -(c_new - c_current);                                                       // difference is what user receives
        require(withdrawl > 0);                                                                     // withdrawl amount must be > 0

        require(tx.outputs[3].lockingBytecode == tx.inputs[2].lockingBytecode);                     // send BCH change to PredictionMarketManager contract
        require(tx.outputs[3].tokenCategory == 0x);                                                 // no tokens in the change
        require(tx.outputs[3].value == tx.inputs[3].value - tx.outputs[4].value);                   // change should the BCH input UTXO value - payout
        
        require(tx.outputs[4].lockingBytecode == tx.inputs[4].lockingBytecode);                     // send BCH to LP
        require(tx.outputs[4].tokenCategory == 0x);                                                 // no tokens in the BCH
        require(tx.outputs[4].value <= withdrawl);                                                  // payout should be less than equal to differences in LMSR costs (can be used to pay for fees)

        int LP_leftover_b = int(LP_b_current) + delta_b;

        if (LP_leftover_b > 0) {
            require(tx.outputs[5].lockingBytecode == tx.inputs[4].lockingBytecode);                 // new receipt NFT should be sent to LP
            require(tx.outputs[5].tokenCategory == tx.inputs[1].tokenCategory.split(32)[0]);        // same token category as the minting receipt NFT but immutable
            require(tx.outputs[5].tokenAmount == 0);                                                // no fungible tokens here
            require(tx.outputs[5].nftCommitment == marketID + bytes6(LP_leftover_b));               // set NFT commitment on receipt = marketID + liquidity leftver after this tx
            require(tx.outputs[5].value == 1000);                                                   // set UTXO satoshis to 1000 (for existence)                
        }                                                                                           // old receipt NFT is implicitly burned
    }
}